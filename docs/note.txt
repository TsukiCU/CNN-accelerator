I am recording some notes during development.
Delete me after everything is done, and start writing real docs.

-------------------- 11.14 --------------------
############
#  Memory  # 
############
cd tests
make
./test_memory

the Memory Allocation Section deals with :
1. Memory block allocation and deallocation regardless of device.
2. Data transfering between CPU and GPU.
3. Concurrency. No data racing should occur.
4. Memory Alignment for optimized performance.
5. Thorough Log information.
6. (Not necessary but very useful) Performance stress tests.

TODO : 3,4,5,6

Issues:
1. It's kind of weird that memory is a .cu file. Not sure if there is a better way of doing this.
2. Initializing with a size of 0: For CPU, ptr_ is not nullptr and for GPU it is. Don't know if this is fine.
3. Unit testing files should include large memory allocation scenarios. Not implemented yet.
4. Move semantics not implemented.

-------------------- 11.15 --------------------

TODO: Specify which files can be .cc and use g++ to compile separately.

**** NOTES for Memory ****
1. data_ is a (void*) pointer, which technically means it does not contain any implied information, and can be
used both as a pointer in CPU and GPU. But this should be done with caution. Use ``cudaPointerGetAttributes``.
2. I allowed copy constructor in MemoryBuffer for very complicated reasons that I am still a little confused.
If possible, always set copy(in Tensor's constructor) to true to avoid potential issues. Copy for MemoryBuffer
is SHALLOW for now. This is a problem(I supppose). It needs to be fixed later.
3. ******** Use SMART POINTER in MemoryBuffer !! This has to be done. ********
4. A static factory method is added which I believe is necessary.

############
#  Tensor  # 
############

1. Tensor is created on CPU if device is not specified.
2. Tensor should not inherit from MemoryBuffer.
3. Tensor is created in strictly row-major order.
4. It's indeed cumbersome that for each arithmetic operation, a switch (dtype_) is required.
There are multiple ways of reducing redundancy, but let's just be happy if it works fine.
5. clone() always return a deep-copy version of the current object. It is, though, not designed to replace copy / move constructor.


-------------------- 11.17 --------------------
1. Tensor created by a vector?
2. Implement at(), fill().  âœ…
3. The old problem oh fuck


-------------------- 11.22 --------------------
1. dispatch_types could be useful for simplifying code structures.
2. operator() for modifying a place.
